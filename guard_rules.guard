# AWS Best Practices CloudFormation Guard Rules
#
# This file contains a consolidated set of CloudFormation Guard rules
# enforcing common best practices across various AWS services.
#
# IMPORTANT: This is a representative set and not an exhaustive list.
# Always review and customize these rules to fit your specific security,
# compliance, and operational requirements.

################################################################################
# AWS::S3::Bucket Best Practices
################################################################################

# Rule: S3 buckets should enforce public access block settings.
# Best Practice: Prevent accidental public access to S3 buckets.
rule s3_bucket_public_access_block {
    Resources.*[
        Type == 'AWS::S3::Bucket'
    ] {
        Properties.PublicAccessBlockConfiguration.BlockPublicAcls == true
        Properties.PublicAccessBlockConfiguration.IgnorePublicAcls == true
        Properties.PublicAccessBlockConfiguration.BlockPublicPolicy == true
        Properties.PublicAccessBlockConfiguration.RestrictPublicBuckets == true
    }
}

# Rule: S3 buckets should have server-side encryption enabled.
# Best Practice: Encrypt data at rest in S3.
rule s3_bucket_encryption_enabled {
    Resources.*[
        Type == 'AWS::S3::Bucket'
    ] {
        Properties.BucketEncryption.ServerSideEncryptionConfiguration ! empty
        Properties.BucketEncryption.ServerSideEncryptionConfiguration.0.ServerSideEncryptionByDefault.SSEAlgorithm IN ["AES256", "aws:kms"]
    }
}

# Rule: S3 buckets should have versioning enabled for data protection.
# Best Practice: Protect against accidental deletions and overwrites.
rule s3_bucket_versioning_enabled {
    Resources.*[
        Type == 'AWS::S3::Bucket'
    ] {
        Properties.VersioningConfiguration.Status == 'Enabled'
    }
}

# Rule: S3 buckets should have logging enabled.
# Best Practice: Enable access logging for auditing and monitoring.
rule s3_bucket_logging_enabled {
    Resources.*[
        Type == 'AWS::S3::Bucket'
    ] {
        Properties.LoggingConfiguration.DestinationBucketName ! empty
    }
}

################################################################################
# AWS::EC2::Instance & related Best Practices
################################################################################

# Rule: EC2 instances should not have a public IP address.
# Best Practice: Use private IPs and NAT Gateway/VPC Endpoints for outbound access.
rule ec2_instance_no_public_ip {
    Resources.*[
        Type == 'AWS::EC2::Instance'
    ] {
        Properties.NetworkInterfaces.*.AssociatePublicIpAddress == false
        Properties.AssociatePublicIpAddress == false # For instances without explicit network interfaces
    }
}

# Rule: EC2 instances should use encrypted EBS volumes.
# Best Practice: Encrypt data at rest for EC2 volumes.
rule ec2_ebs_volume_encrypted {
    Resources.*[
        Type == 'AWS::EC2::Volume'
    ] {
        Properties.Encrypted == true
    }
    Resources.*[
        Type == 'AWS::EC2::Instance'
    ] {
        Properties.BlockDeviceMappings.*.Ebs.Encrypted == true
    }
}

# Rule: EC2 instances should have detailed monitoring enabled.
# Best Practice: Enable CloudWatch detailed monitoring for better insights.
rule ec2_instance_detailed_monitoring {
    Resources.*[
        Type == 'AWS::EC2::Instance'
    ] {
        Properties.Monitoring.Enabled == true
    }
}

################################################################################
# AWS::EC2::SecurityGroup Best Practices
################################################################################

# Rule: Security groups should not allow unrestricted ingress (0.0.0.0/0) for common sensitive ports.
# Best Practice: Restrict ingress to known IPs for sensitive services.
rule security_group_no_unrestricted_sensitive_ingress {
    Resources.*[
        Type == 'AWS::EC2::SecurityGroupIngress'
    ] {
        Properties.CidrIp != "0.0.0.0/0" OR
        Properties.IpRanges.*.CidrIp != "0.0.0.0/0" OR
        Properties.FromPort IN [22, 3389, 20, 21, 23, 110, 143, 445, 3306, 5432] == false
    }
    Resources.*[
        Type == 'AWS::EC2::SecurityGroup'
    ] {
        Properties.SecurityGroupIngress.*.CidrIp != "0.0.0.0/0" OR
        Properties.SecurityGroupIngress.*.IpRanges.*.CidrIp != "0.0.0.0/0" OR
        Properties.SecurityGroupIngress.*.FromPort IN [22, 3389, 20, 21, 23, 110, 143, 445, 3306, 5432] == false
    }
}

# Rule: Security groups should not allow unrestricted egress (0.0.0.0/0).
# Best Practice: Restrict outbound traffic to only necessary destinations.
rule security_group_no_unrestricted_egress {
    Resources.*[
        Type == 'AWS::EC2::SecurityGroupEgress'
    ] {
        Properties.CidrIp != "0.0.0.0/0"
    }
    Resources.*[
        Type == 'AWS::EC2::SecurityGroup'
    ] {
        Properties.SecurityGroupEgress.*.CidrIp != "0.0.0.0/0" OR
        Properties.SecurityGroupEgress.*.IpRanges.*.CidrIp != "0.0.0.0/0"
    }
}

################################################################################
# AWS::IAM::Role / AWS::IAM::Policy Best Practices
################################################################################

# Rule: IAM Policies should not allow "*" for "Effect": "Allow" on "Action".
# Best Practice: Enforce least privilege.
rule iam_policy_no_wildcard_actions {
    Resources.*[
        Type == 'AWS::IAM::Policy' || Type == 'AWS::IAM::Role' || Type == 'AWS::IAM::User' || Type == 'AWS::IAM::Group'
    ] {
        Properties.PolicyDocument.Statement.*[
            Effect == 'Allow'
        ].Action != '*'
    }
}

# Rule: IAM Policies should not allow "*" for "Effect": "Allow" on "Resource".
# Best Practice: Enforce least privilege.
rule iam_policy_no_wildcard_resources {
    Resources.*[
        Type == 'AWS::IAM::Policy' || Type == 'AWS::IAM::Role' || Type == 'AWS::IAM::User' || Type == 'AWS::IAM::Group'
    ] {
        Properties.PolicyDocument.Statement.*[
            Effect == 'Allow'
        ].Resource != '*'
    }
}

# Rule: IAM Roles should have a trust policy defined.
# Best Practice: Explicitly define who can assume the role.
rule iam_role_trust_policy_defined {
    Resources.*[
        Type == 'AWS::IAM::Role'
    ] {
        Properties.AssumeRolePolicyDocument ! empty
    }
}

################################################################################
# AWS::RDS::DBInstance Best Practices
################################################################################

# Rule: RDS DB Instances should have storage encryption enabled.
# Best Practice: Encrypt data at rest for databases.
rule rds_db_instance_storage_encrypted {
    Resources.*[
        Type == 'AWS::RDS::DBInstance'
    ] {
        Properties.StorageEncrypted == true
    }
}

# Rule: RDS DB Instances should have automated backups enabled.
# Best Practice: Enable backups for data recovery.
rule rds_db_instance_backups_enabled {
    Resources.*[
        Type == 'AWS::RDS::DBInstance'
    ] {
        Properties.BackupRetentionPeriod > 0
    }
}

# Rule: RDS DB Instances should be deployed in a Multi-AZ configuration.
# Best Practice: Improve availability and fault tolerance.
rule rds_db_instance_multi_az {
    Resources.*[
        Type == 'AWS::RDS::DBInstance'
    ] {
        Properties.MultiAZ == true
    }
}

################################################################################
# AWS::Lambda::Function Best Practices
################################################################################

# Rule: Lambda functions should be configured with a Dead Letter Queue (DLQ).
# Best Practice: Handle asynchronous invocation failures gracefully.
rule lambda_function_dlq_configured {
    Resources.*[
        Type == 'AWS::Lambda::Function'
    ] {
        Properties.DeadLetterConfig.TargetArn ! empty
    }
}

# Rule: Lambda functions should have tracing enabled.
# Best Practice: Enable X-Ray tracing for better observability.
rule lambda_function_tracing_enabled {
    Resources.*[
        Type == 'AWS::Lambda::Function'
    ] {
        Properties.TracingConfig.Mode IN ["Active", "PassThrough"]
    }
}

################################################################################
# AWS::CloudWatch::Alarm Best Practices
################################################################################

# Rule: CloudWatch Alarms should have sufficient data points to alarm.
# Best Practice: Prevent flapping alarms due to insufficient data.
rule cloudwatch_alarm_sufficient_data_points {
    Resources.*[
        Type == 'AWS::CloudWatch::Alarm'
    ] {
        Properties.DatapointsToAlarm <= Properties.EvaluationPeriods
    }
}

################################################################################
# AWS::VPC::VPC Best Practices
################################################################################

# Rule: VPCs should have Flow Logs enabled.
# Best Practice: Monitor network traffic for security and troubleshooting.
rule vpc_flow_logs_enabled {
    Resources.*[
        Type == 'AWS::EC2::FlowLog'
    ] {
        Properties.ResourceId ! empty
        Properties.DeliverLogsPermissionArn ! empty
        Properties.LogGroupName ! empty
        Properties.TrafficType IN ["ALL", "ACCEPT", "REJECT"]
    }
}

# Rule: Network ACLs should not have overly permissive rules (e.g., allow all ingress/egress).
# Best Practice: Follow least privilege for network access.
rule network_acl_no_permissive_rules {
    Resources.*[
        Type == 'AWS::EC2::NetworkAclEntry'
    ] {
        Properties.CidrBlock != "0.0.0.0/0" OR
        Properties.RuleAction == "deny" OR
        Properties.PortRange.From != 0 OR
        Properties.PortRange.To != 65535 OR
        Properties.Protocol != "-1" # -1 means all protocols
    }
}

################################################################################
# AWS::CloudFront::Distribution Best Practices
################################################################################

# Rule: CloudFront distributions should enforce HTTPS viewer protocol policy.
# Best Practice: Encrypt traffic between viewers and CloudFront.
rule cloudfront_distribution_https_viewer_policy {
    Resources.*[
        Type == 'AWS::CloudFront::Distribution'
    ] {
        Properties.DistributionConfig.ViewerCertViewerProtocolPolicy IN ["redirect-to-https", "https-only"]
    }
}

# Rule: CloudFront distributions should be associated with a WAF Web ACL.
# Best Practice: Protect against common web exploits.
rule cloudfront_distribution_waf_associated {
    Resources.*[
        Type == 'AWS::CloudFront::Distribution'
    ] {
        Properties.DistributionConfig.WebACLId ! empty
    }
}

################################################################################
# AWS::DynamoDB::Table Best Practices
################################################################################

# Rule: DynamoDB tables should have server-side encryption enabled.
# Best Practice: Encrypt data at rest for DynamoDB.
rule dynamodb_table_encryption_enabled {
    Resources.*[
        Type == 'AWS::DynamoDB::Table'
    ] {
        Properties.SSESpecification.SSEEnabled == true
    }
}

# Rule: DynamoDB tables should have Point-in-Time Recovery enabled.
# Best Practice: Enable continuous backups for accidental writes/deletes.
rule dynamodb_table_point_in_time_recovery_enabled {
    Resources.*[
        Type == 'AWS::DynamoDB::Table'
    ] {
        Properties.PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled == true
    }
}

################################################################################
# AWS::KMS::Key Best Practices
################################################################################

# Rule: KMS keys should have key rotation enabled.
# Best Practice: Periodically rotate encryption keys for enhanced security.
rule kms_key_rotation_enabled {
    Resources.*[
        Type == 'AWS::KMS::Key'
    ] {
        Properties.EnableKeyRotation == true
    }
}

################################################################################
# AWS::SQS::Queue Best Practices
################################################################################

# Rule: SQS queues should have server-side encryption enabled.
# Best Practice: Encrypt messages at rest in SQS queues.
rule sqs_queue_encryption_enabled {
    Resources.*[
        Type == 'AWS::SQS::Queue'
    ] {
        Properties.KmsMasterKeyId ! empty OR Properties.SqsManagedSseEnabled == true
    }
}

################################################################################
# AWS::SNS::Topic Best Practices
################################################################################

# Rule: SNS topics should have server-side encryption enabled.
# Best Practice: Encrypt messages at rest in SNS topics.
rule sns_topic_encryption_enabled {
    Resources.*[
        Type == 'AWS::SNS::Topic'
    ] {
        Properties.KmsMasterKeyId ! empty
    }
}

################################################################################
# AWS::ECR::Repository Best Practices
################################################################################

# Rule: ECR repositories should have image scanning enabled.
# Best Practice: Automatically scan container images for vulnerabilities.
rule ecr_repository_image_scanning_enabled {
    Resources.*[
        Type == 'AWS::ECR::Repository'
    ] {
        Properties.ImageScanningConfiguration.ScanOnPush == true
    }
}
